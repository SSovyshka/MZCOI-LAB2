# Лабораторна робота: Дискретизація та відновлення аналогового сигналу

[![Python](https://img.shields.io/badge/Python-3.8%2B-blue)](https://www.python.org/)
[![NumPy](https://img.shields.io/badge/NumPy-1.20%2B-orange)](https://numpy.org/)
[![Matplotlib](https://img.shields.io/badge/Matplotlib-3.4%2B-orange)](https://matplotlib.org/)

Проект демонструє процес дискретизації аналогового сигналу та його відновлення за допомогою інтерполяції функцією sinc.

## Зміст
1. [Опис](#опис)
2. [Вимоги](#вимоги)
3. [Код програми](#програма)
4. [Результати](#результати)
5. [Висновки](#висновки)

## Опис 

Мета роботи: вивчення процесу дискретизації аналогового сигналу в цифрових системах.

## Вимоги
Дискретизувати аналогову функцію згідно з варіантом, де m = 1 ( КІУКІ-24-1 ). Параметри дискретизації обрати
самостійно.

| Варіант     | Функція                       |
|-------------|-------------------------------|
| 17          | x(t) = – m cos (5.65t + π/ m) |

## Програма

Ось вихідні параметри для 17-го варіанту:

```python
# Параметри сигналу
m = 1               # Коефіцієнт (номер групи)
A = -m              # Амплітуда сигналу
omega = 5.65        # Кутова частота
phi = np.pi / m     # Початкова фаза

# Параметри дискретизації
Td = 0.1            # Період дискретизації
N = 10              # Кількість відліків
```

Реалізація алгоритму обробки сигналу

1. Генерація аналогового сигналу
```python
# Створюємо часову шкалу для аналогового сигналу
# від 0 до N*Td (1.0 сек) з 1000 точками
t_analog = np.linspace(0, N * Td, 1000)

# Обчислюємо значення аналогового сигналу
x_analog = A * np.cos(omega * t_analog + phi)
```

2. Дискретизація сигналу
```python
# Створюємо масив індексів відліків
n = np.arange(N)

# Обчислюємо моменти часу для дискретних відліків
t_discrete = n * Td  # [0.0, 0.1, 0.2, ..., 0.9]

# Обчислюємо значення дискретного сигналу
x_discrete = A * np.cos(omega * t_discrete + phi)
```

3. Відновлення сигналу
```python
# Кількість членів ряду для інтерполяції
K = 10

# Часова шкала для відновленого сигналу 
t_reconstructed = np.linspace(0, N * Td, 1000)

# Ініціалізація масиву відновленого сигналу
x_reconstructed = np.zeros_like(t_reconstructed)

# Інтерполяція sinc-функцією (формула Котельникова-Шеннона)
for k in range(K):
    x_reconstructed += x_discrete[k] * np.sinc(np.pi * (t_reconstructed / Td - k))
```

Малювання графіку
```python
# ---------------------------------------------------------------------------
# Синя лінія: аналоговий сигнал x(t).
# Червоні точки: дискретні відліки x(nTd).
# Зелена пунктирна лінія: відновлений сигнал за допомогою інтерполяції sinc.
# ---------------------------------------------------------------------------

plt.figure(figsize=(10, 6))
plt.plot(t_analog, x_analog, 'b-', label='Аналоговий сигнал')
plt.stem(t_discrete, x_discrete, linefmt='r-', markerfmt='ro', basefmt=' ', label='Дискретні відліки')
plt.plot(t_reconstructed, x_reconstructed, 'g--', label='Відновлений сигнал')


plt.title('Дискретизація та відновлення сигналу')
plt.xlabel('Час (с)')
plt.ylabel('Амплітуда')
plt.legend()
plt.grid()
plt.show()
```

Результати в консолі
```python
print("--------------------------\nДискретні відліки сигналу:\n--------------------------\n")
for i, val in enumerate(x_discrete):
    print(f"x{i + 1} = {val:.8f}")

# Відносна похибка для прикладу (t = 0.15)
t_example = 0.15
x_analog_example = A * np.cos(omega * t_example + phi)
x_reconstructed_example = np.sum([x_discrete[k] * np.sinc(np.pi * (t_example / Td - k)) for k in range(K)])
error = np.abs((x_analog_example - x_reconstructed_example) / x_analog_example) * 100

print(f"\n--------------------------\nВідносна похибка відновлення\n--------------------------\nt = {t_example} с: {error:.2f}%")
```


## Результати
## Висновки
